require('dotenv').config();
const { Client, GatewayIntentBits, REST, Routes, SlashCommandBuilder } = require('discord.js');
const OpenAI = require('openai');
const https = require('https');
const { URL } = require('url');
const { loadAgentWithDependencies } = require('./bmad-loader');

// ËºâÂÖ• PO agent ÂèäÂÖ∂‰æùË≥¥
const poAgent = loadAgentWithDependencies('po');

// ÂÑ≤Â≠òÂ∞çË©±Ê≠∑Âè≤
const conversationHistory = new Map();

/**
 * ‰ª• https.request Â∞ÅË£ù GitHub API POST ÂëºÂè´
 */
function postJson(url, token, payload) {
  return new Promise((resolve, reject) => {
    const endpoint = new URL(url);
    const options = {
      hostname: endpoint.hostname,
      path: `${endpoint.pathname}${endpoint.search}`,
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github+json',
        'Content-Type': 'application/json',
        'User-Agent': 'vibehub-po-bot'
      }
    };

    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', (chunk) => { data += chunk; });
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve(data);
        } else {
          const message = data || res.statusMessage || `HTTP ${res.statusCode}`;
          reject(new Error(`GitHub API error ${res.statusCode}: ${message}`));
        }
      });
    });

    req.on('error', reject);
    req.write(JSON.stringify(payload));
    req.end();
  });
}

function slugify(text) {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '') || 'story';
}

function extractStorySummary(content) {
  const storyLine = content.match(/Story:\s*(.+)/i);
  if (storyLine && storyLine[1]) {
    return storyLine[1].replace(/\*\*/g, '').trim();
  }

  const headingMatch = content.match(/^#+\s*(.+)$/m);
  if (headingMatch && headingMatch[1]) {
    return headingMatch[1].trim();
  }

  const firstLine = content.split('\n').find(line => line.trim().length > 0);
  return firstLine ? firstLine.trim() : 'New story';
}

function buildStoryFilename(summary) {
  const datePrefix = new Date().toISOString().split('T')[0];
  const slug = slugify(summary).slice(0, 50);
  return `stories/${datePrefix}-${slug}.md`;
}

async function triggerStoryWorkflow({ filename, content, summary }) {
  const token = process.env.PO_BOT_GH_PAT;
  if (!token) {
    throw new Error('Áº∫Â∞ëÁí∞Â¢ÉËÆäÊï∏ PO_BOT_GH_PAT');
  }

  const owner = process.env.PO_BOT_GH_OWNER || 'terrytykuo';
  const repo = process.env.PO_BOT_GH_REPO || 'vibehub';
  const workflow = process.env.PO_BOT_GH_WORKFLOW || 'story-pr.yml';

  const safeSummary = summary.length > 100 ? `${summary.slice(0, 97)}...` : summary;

  const url = `https://api.github.com/repos/${owner}/${repo}/actions/workflows/${workflow}/dispatches`;
  const payload = {
    ref: 'main',
    inputs: {
      story_filename: filename,
      story_content_base64: Buffer.from(content, 'utf8').toString('base64'),
      story_summary: safeSummary
    }
  };

  await postJson(url, token, payload);
  return safeSummary;
}

// ÂÆöÁæ© slash commands
const commands = [
  new SlashCommandBuilder()
    .setName('help')
    .setDescription('È°ØÁ§∫ PO (Sarah) ÊâÄÊúâÂèØÁî®ÂëΩ‰ª§'),

  new SlashCommandBuilder()
    .setName('create-epic')
    .setDescription('Âª∫Á´ã EpicÔºàÈÅ©Áî®Êñº brownfield Â∞àÊ°àÔºâ')
    .addStringOption(option =>
      option
        .setName('description')
        .setDescription('Epic ÊèèËø∞')
        .setRequired(true)
    ),

  new SlashCommandBuilder()
    .setName('create-story')
    .setDescription('Ê†πÊìöÈúÄÊ±ÇÂª∫Á´ã User Story')
    .addStringOption(option =>
      option
        .setName('requirements')
        .setDescription('Story ÈúÄÊ±ÇÊèèËø∞')
        .setRequired(true)
    ),

  new SlashCommandBuilder()
    .setName('create-pr')
    .setDescription('Ê†πÊìöÊèê‰æõÁöÑ Story ÂÖßÂÆπÂª∫Á´ã Pull Request')
    .addStringOption(option =>
      option
        .setName('story')
        .setDescription('Story ÂÆåÊï¥ÂÖßÂÆπÔºàMarkdownÔºâ')
        .setRequired(true)
    ),

  new SlashCommandBuilder()
    .setName('validate-story')
    .setDescription('È©óË≠â Story ÁöÑÂÆåÊï¥ÊÄß')
    .addStringOption(option =>
      option
        .setName('story')
        .setDescription('Story ÂÖßÂÆπÔºàÂèØÂú® thread ‰∏≠Ë≤º‰∏äÂÆåÊï¥ÂÖßÂÆπÔºâ')
        .setRequired(false)
    ),

  new SlashCommandBuilder()
    .setName('correct-course')
    .setDescription('Âü∑Ë°å correct-course ‰ªªÂãô'),

  new SlashCommandBuilder()
    .setName('shard-doc')
    .setDescription('ÂàÜÂâ≤Êñá‰ª∂')
    .addStringOption(option =>
      option
        .setName('document')
        .setDescription('Ë¶ÅÂàÜÂâ≤ÁöÑÊñá‰ª∂ÂÖßÂÆπ')
        .setRequired(false)
    ),

  new SlashCommandBuilder()
    .setName('execute-checklist')
    .setDescription('Âü∑Ë°å PO master checklist'),

  new SlashCommandBuilder()
    .setName('clear')
    .setDescription('Ê∏ÖÈô§Ê≠§ channel ÁöÑÂ∞çË©±Ê≠∑Âè≤'),
];

/**
 * Âª∫Êßã PO persona system message
 */
function buildSystemMessage(commandName, dependencies = {}) {
  let systemMessage = `You are Sarah, the Product Owner (PO) from BMAD methodology.

${poAgent.agent.fullContent}

`;

  // Âä†ÂÖ• core config
  if (poAgent.coreConfig) {
    systemMessage += `\n## Project Configuration\n${poAgent.coreConfig}\n`;
  }

  // Ê†πÊìöÂëΩ‰ª§Âä†ÂÖ•Áõ∏Èóú‰æùË≥¥
  if (dependencies.tasks) {
    dependencies.tasks.forEach(taskName => {
      if (poAgent.tasks[taskName]) {
        systemMessage += `\n## Task: ${taskName}\n${poAgent.tasks[taskName]}\n`;
      }
    });
  }

  if (dependencies.templates) {
    dependencies.templates.forEach(templateName => {
      if (poAgent.templates[templateName]) {
        systemMessage += `\n## Template: ${templateName}\n${poAgent.templates[templateName]}\n`;
      }
    });
  }

  if (dependencies.checklists) {
    dependencies.checklists.forEach(checklistName => {
      if (poAgent.checklists[checklistName]) {
        systemMessage += `\n## Checklist: ${checklistName}\n${poAgent.checklists[checklistName]}\n`;
      }
    });
  }

  systemMessage += `\nYou are operating in Discord. Provide clear, structured responses. For long outputs, they will be automatically posted in a thread.`;

  return systemMessage;
}

/**
 * ËôïÁêÜÈï∑ÂõûÊáâÔºåËá™ÂãïÂª∫Á´ã thread
 */
async function handleLongResponse(interaction, response, questionPreview) {
  if (response.length > 2000) {
    // ÁôºÈÄÅÂâç 2000 Â≠óÂÖÉ
    await interaction.editReply(response.substring(0, 2000));

    // Âª∫Á´ã thread
    const thread = await interaction.channel.threads.create({
      name: `üìù PO: ${questionPreview.substring(0, 50)}...`,
      autoArchiveDuration: 60,
    });

    // ÁôºÈÄÅÂâ©È§òÂÖßÂÆπ
    let remaining = response.substring(2000);
    while (remaining.length > 0) {
      await thread.send(remaining.substring(0, 2000));
      remaining = remaining.substring(2000);
    }

    return thread;
  } else {
    await interaction.editReply(response);
    return null;
  }
}

/**
 * ÂëºÂè´ OpenAI API
 */
async function callOpenAI(systemMessage, userMessage, history = []) {
  const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
  });

  const messages = [
    { role: 'system', content: systemMessage },
    ...history,
    { role: 'user', content: userMessage }
  ];

  const response = await openai.chat.completions.create({
    model: 'gpt-4o',
    messages: messages,
    max_tokens: 4000,
    temperature: 0.7,
  });

  return response.choices[0].message.content;
}

async function start() {
  const client = new Client({
    intents: [
      GatewayIntentBits.Guilds,
      GatewayIntentBits.GuildMessages,
      GatewayIntentBits.MessageContent,
    ],
  });

  // Ë®ªÂÜä slash commands
  async function registerCommands() {
    const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN_PO);

    try {
      console.log('[PO Bot] Started refreshing application (/) commands.');

      await rest.put(
        Routes.applicationCommands(client.user.id),
        { body: commands },
      );

      console.log('[PO Bot] Successfully reloaded application (/) commands.');
    } catch (error) {
      console.error('[PO Bot] Error registering commands:', error);
    }
  }

  // Bot Ê∫ñÂÇôÂ•ΩÊôÇ
  client.once('ready', async () => {
    console.log(`‚úÖ [PO Bot] Logged in as ${client.user.tag} - Sarah (Product Owner)`);
    await registerCommands();
  });

  // ËôïÁêÜ slash commands
  client.on('interactionCreate', async (interaction) => {
    if (!interaction.isChatInputCommand()) return;

    const { commandName, channelId } = interaction;

    try {
      await interaction.deferReply();

      // Ê∫ñÂÇôÂ∞çË©±Ê≠∑Âè≤
      if (!conversationHistory.has(channelId)) {
        conversationHistory.set(channelId, []);
      }
      const history = conversationHistory.get(channelId);

      let systemMessage, userMessage, dependencies;
      let requirements, epicDesc, story, document;

      switch (commandName) {
        case 'help':
          systemMessage = buildSystemMessage('help');
          userMessage = 'Please show me all available commands with descriptions. Format as a numbered list.';
          break;

        case 'create-epic':
          epicDesc = interaction.options.getString('description');
          dependencies = {
            tasks: ['brownfield-create-epic'],
            templates: []
          };
          systemMessage = buildSystemMessage('create-epic', dependencies);
          userMessage = `Execute the brownfield-create-epic task to create a complete epic based on this description:

${epicDesc}

IMPORTANT: Follow the task instructions exactly. Create a structured epic document with all required sections as defined in the task. The epic should include goals, scope, user stories breakdown, technical considerations, and success criteria.`;
          break;

        case 'create-story':
          requirements = interaction.options.getString('requirements');
          dependencies = {
            tasks: ['create-brownfield-story'],
            templates: ['story-tmpl.yaml']
          };
          systemMessage = buildSystemMessage('create-story', dependencies);
          userMessage = `Execute the create-brownfield-story task to create a complete, structured user story based on these requirements:

${requirements}

IMPORTANT: Follow the task instructions completely. Create a full markdown story document that includes:
- Status (Draft)
- Story (As a... I want... so that...)
- Acceptance Criteria (numbered list)
- Tasks/Subtasks (checkbox list with subtasks)
- Dev Notes (with technical guidance)
- Testing section
- Change Log
- Dev Agent Record sections

The story should be implementation-ready for the Dev agent. Format it as a complete markdown document, not just a brief summary.`;
          break;

        case 'create-pr':
          story = interaction.options.getString('story');
          if (!story) {
            await interaction.editReply('‚ùå Ë´ãÊèê‰æõÂÆåÊï¥ÁöÑ Story ÂÖßÂÆπ„ÄÇ');
            return;
          }

          try {
            const summary = extractStorySummary(story);
            const filename = buildStoryFilename(summary);
            const safeSummary = await triggerStoryWorkflow({
              filename,
              content: story,
              summary
            });

            await interaction.editReply(
              `üöÄ Â∑≤Ëß∏Áôº GitHub Action Âª∫Á´ã Pull Request„ÄÇ\n‚Ä¢ Ê™îÊ°àÔºö\`${filename}\`\n‚Ä¢ PR Ê®ôÈ°åÔºöAdd story: ${safeSummary}\nË´ãÁ®çÂÄôÊñº GitHub Actions Êü•Ë©¢Âü∑Ë°åÊÉÖÊ≥Å„ÄÇ`
            );
          } catch (workflowError) {
            console.error('[PO Bot] Error triggering story workflow:', workflowError);
            await interaction.editReply(`‚ö†Ô∏è Ëß∏Áôº GitHub Action Â§±ÊïóÔºö${workflowError.message}`);
          }
          return;

        case 'validate-story':
          story = interaction.options.getString('story');
          if (!story) {
            await interaction.editReply('Ë´ãÂú® thread ‰∏≠Êèê‰æõÂÆåÊï¥ÁöÑ story ÂÖßÂÆπÔºåÊàñ‰ΩøÁî® story ÂèÉÊï∏„ÄÇ');
            return;
          }
          dependencies = {
            tasks: ['validate-next-story']
          };
          systemMessage = buildSystemMessage('validate-story', dependencies);
          userMessage = `Execute the validate-next-story task to thoroughly validate this story:

${story}

Follow the task instructions to check for completeness, clarity, and implementation-readiness. Provide detailed feedback on any issues found.`;
          break;

        case 'correct-course':
          dependencies = {
            tasks: ['correct-course']
          };
          systemMessage = buildSystemMessage('correct-course', dependencies);
          userMessage = 'Execute the correct-course task';
          break;

        case 'shard-doc':
          document = interaction.options.getString('document');
          if (!document) {
            await interaction.editReply('Ë´ãÂú® thread ‰∏≠Êèê‰æõÂÆåÊï¥ÁöÑÊñá‰ª∂ÂÖßÂÆπÔºåÊàñ‰ΩøÁî® document ÂèÉÊï∏„ÄÇ');
            return;
          }
          dependencies = {
            tasks: ['shard-doc']
          };
          systemMessage = buildSystemMessage('shard-doc', dependencies);
          userMessage = `Shard this document:\n${document}`;
          break;

        case 'execute-checklist':
          dependencies = {
            tasks: ['execute-checklist'],
            checklists: ['po-master-checklist']
          };
          systemMessage = buildSystemMessage('execute-checklist', dependencies);
          userMessage = 'Execute the PO master checklist';
          break;

        case 'clear':
          conversationHistory.delete(channelId);
          await interaction.editReply('‚úÖ Â∑≤Ê∏ÖÈô§Ê≠§ channel ÁöÑÂ∞çË©±Ê≠∑Âè≤„ÄÇ');
          return;

        default:
          await interaction.editReply('‚ùå Unknown command');
          return;
      }

      // ÂëºÂè´ OpenAI
      const response = await callOpenAI(systemMessage, userMessage, history);

      // Êõ¥Êñ∞Ê≠∑Âè≤
      history.push({ role: 'user', content: userMessage });
      history.push({ role: 'assistant', content: response });

      // È°ØÁ§∫‰ΩøÁî®ËÄÖÁöÑË´ãÊ±ÇÔºàËÆìÂÖ∂‰ªñ‰∫∫‰πüËÉΩÁúãÂà∞Ôºâ
      let displayMessage = '';
      if (commandName === 'create-story') {
        displayMessage = `üìù **Creating Story**\nRequirements: ${requirements}\n\n---\n\n${response}`;
      } else if (commandName === 'create-epic') {
        displayMessage = `üìã **Creating Epic**\nDescription: ${epicDesc}\n\n---\n\n${response}`;
      } else if (commandName === 'validate-story') {
        displayMessage = `‚úÖ **Validating Story**\n\n---\n\n${response}`;
      } else {
        displayMessage = response;
      }

      // ËôïÁêÜÈï∑ÂõûÊáâ
      await handleLongResponse(interaction, displayMessage, commandName);

    } catch (error) {
      console.error('[PO Bot] Error:', error);
      await interaction.editReply('‚ùå ËôïÁêÜË´ãÊ±ÇÊôÇÁôºÁîüÈåØË™§„ÄÇ');
    }
  });

  // Âú® thread ‰∏≠ÁöÑÂ∞çË©±
  client.on('messageCreate', async (message) => {
    if (message.author.bot) return;
    if (!message.channel.isThread()) return;

    const starterMessage = await message.channel.fetchStarterMessage();
    if (!starterMessage || starterMessage.author.id !== client.user.id) return;

    try {
      await message.channel.sendTyping();

      const threadId = message.channel.id;

      if (!conversationHistory.has(threadId)) {
        conversationHistory.set(threadId, []);
      }

      const history = conversationHistory.get(threadId);
      const systemMessage = buildSystemMessage('thread');

      const response = await callOpenAI(systemMessage, message.content, history);

      history.push({ role: 'user', content: message.content });
      history.push({ role: 'assistant', content: response });

      // Âú® thread ‰∏≠ÁôºÈÄÅÔºàÂèØËÉΩÂàÜÊÆµÔºâ
      if (response.length > 2000) {
        let remaining = response;
        while (remaining.length > 0) {
          await message.reply(remaining.substring(0, 2000));
          remaining = remaining.substring(2000);
        }
      } else {
        await message.reply(response);
      }

    } catch (error) {
      console.error('[PO Bot] Error in thread conversation:', error);
      await message.reply('‚ùå ËôïÁêÜË®äÊÅØÊôÇÁôºÁîüÈåØË™§„ÄÇ');
    }
  });

  // ÁôªÂÖ• Discord
  client.login(process.env.DISCORD_TOKEN_PO);
}

module.exports = { start };
